Attribute VB_Name = "History"
'Description
'  sets up constants and arrays for tracking the
'  last x number of functions called, their arguments
'  and return values

   Const mMaxFuncs = DClearAlarm   '139 - last locally defined function
   Dim mnFuncList(mMaxFuncs) As Integer
   Dim mnFunctionHistory
   Dim mnHistoryFile        'DONTSAVE, SAVEERRORS, SAVEALL
   
   Global gnScriptSave As Integer
   Global gnScriptRun As Integer, gnUniScript As Integer
   Global gnCurFunc As Integer, gnScriptPaused As Integer
   Global gnShowComments As Integer
   Global gnPrintEval As Integer
   Global gnPrintEvalAll As Integer
   Global gnPauseEval As Integer, gnErrFlag As Integer
   Global gnLogComments As Integer
   Global gnLogEvalFail As Integer
   Global gnLogEvalAll As Integer

   Dim mavFuncsCalled() As Variant
   'mavFuncsCalled is a history of the last
   'mnFunctionHistory (10 by default) functions
   'called (first dimension) specifying the function
   '(using constants below), its return value (usually
   'error code), the number of arguments and the
   'value of each argument
   'if an array is generated by multiple calls to a function
   'that returns only one value in the data argument, (for
   'example, cbAIn()) and the data is transfered to a
   'Windows buffer, the handle to that buffer should be
   'stored in the last element (mavFuncsCalled(x, 14))
   
   Global Const DONTSAVE = 0
   Global Const SAVEERRORS = 1
   Global Const SAVEALL = 2


   'USB library
   Global Const USBBlink = 8001
   Global Const USBReset = 8002
   Global Const USBGetSerialNum = 8003
   Global Const USBSetSerialNum = 8004
   Global Const USBMemRead = 8005
   Global Const USBMemWrite = 8006
   Global Const USBWatchdog = 8007
   Global Const USBAInScan = 8008
   Global Const USBALoadQueue = 8009
   Global Const USBAIn = 8010
   Global Const USBAOut = 8011
   Global Const USBDConfigPort = 8012
   Global Const USBDIn = 8013
   Global Const USBDOut = 8014
   Global Const USBDBitIn = 8015
   Global Const USBDBitOut = 8016
   Global Const USBGetStatus = 8017
   Global Const USBGetErrMsg = 8018
   Global Const USBDConfigBit = 8019
   Global Const USBStopBackground = 8021
   Global Const USBCInit = 8022
   Global Const USBCIn32 = 8023
   Global Const USBFromEngUnits = 8024
   Global Const USBToEngUnits = 8025
   Global Const USBDSetTrig = 8026
   Global Const USBSaveConfig = 8027
   
   
   'Win API functions
   Global Const WinAPIGlobalAlloc = &H1001
   Global Const WinAPIGlobalFree = &H1002
   Global Const WinAPICreateFileMapping = &H1003
   Global Const WinAPIMapViewOfFile = &H1004
   Global Const WinAPIUnmapViewOfFile = &H1005
   Global Const WinAPIOpenFileMapping = &H1006

Sub ClearBuffer()

   For i% = 0 To mnFunctionHistory - 1
      For e% = 0 To 14
         mavFuncsCalled(i%, e%) = 0
      Next e%
   Next i%

End Sub

Function FindFunction(FuncID As Integer, FuncStat, ArgVals() As Variant) As Integer

   NumFuncsSaved% = mnFunctionHistory - 1
   
   For HistIndex% = 0 To NumFuncsSaved%
      If FuncID = mavFuncsCalled(HistIndex%, 0) Then
         FunctionFound% = True
         Exit For
      End If
   Next HistIndex%
   If FunctionFound% Then
      FuncStat = mavFuncsCalled(HistIndex%, 1)
      For FuncArgs% = 0 To 12
         ArgVals(FuncArgs%) = mavFuncsCalled(HistIndex%, FuncArgs% + 2)
      Next FuncArgs%
      FindFunction = FunctionFound%
   End If

End Function

Sub GetFuncsSaved(FuncList() As Integer)

   LastFunc% = UBound(FuncList)
   If LastFunc% > mMaxFuncs Then
      For spare% = mMaxFuncs + 1 To LastFunc%
         FuncList(spare%) = True
      Next spare%
      LastFunc% = mMaxFuncs
   End If
   For i% = 1 To LastFunc%
      FuncList(i%) = mnFuncList(i%)
   Next i%

End Sub

Function GetHistory() As Integer

   GetHistory = mnFunctionHistory

End Function

Sub GetHistoryArray(ArrayToFill() As Variant)

   On Error GoTo ReportError
   If UBound(ArrayToFill, 1) < mnFunctionHistory - 1 Then GoTo ReportError
   If UBound(ArrayToFill, 2) < 14 Then GoTo ReportError
   FuncList% = gnCurFunc
   NumFuncsSaved% = mnFunctionHistory - 1
   Do
      FuncList% = FuncList% - 1
      If FuncList% < 0 Then FuncList% = NumFuncsSaved%
      For i% = 0 To 14
         ArrayToFill(FuncList%, i%) = mavFuncsCalled(FuncList%, i%)
      Next i%
   Loop While FuncList% <> gnCurFunc
   Exit Sub

ReportError:
   Select Case Err
      Case 0
         MsgBox "Array for function history not properly dimensioned."
      Case Else
         MsgBox "Error filling function history array: " & Error$(Err)
   End Select
   Exit Sub

End Sub

Function GetHistoryText() As String

   FuncList% = gnCurFunc
   NumFuncsSaved% = mnFunctionHistory - 1
   Do
      If mnHistoryFile = SAVEALL Then
         FuncList% = FuncList% + 1
         If FuncList% > NumFuncsSaved% Then FuncList% = 0
      Else
         FuncList% = FuncList% - 1
         If FuncList% < 0 Then FuncList% = NumFuncsSaved% - 1
      End If
      SavedFunction = mavFuncsCalled(FuncList%, 0)
      If IsEmpty(SavedFunction) Then
         Exit Do
      End If
      If IsNumeric(SavedFunction) And gbULLoaded Then
         FuncID% = mavFuncsCalled(FuncList%, 0)
         NumArgs% = GetNumArgs(FuncID%)
      Else
         FuncID% = -1
      End If
      Select Case FuncID%
         Case 0
         Case WinBufAlloc, WinBufAlloc32, WinBufAlloc64, ScaledWinBufAlloc
            If gnHexVals Then
               ReturnVal$ = "0x" & Hex$(mavFuncsCalled(FuncList%, 1))
            Else
               ReturnVal$ = mavFuncsCalled(FuncList%, 1)
            End If
            LibFunction$ = GetFunctionString(FuncID%)
            ArgString$ = "Arg Vals: "
            For i% = 1 To NumArgs%
               If gnHexVals Then
                  ArgString$ = ArgString$ & "0x" & Hex$(mavFuncsCalled(FuncList%, 1 + i%)) & ", "
               Else
                  ArgString$ = ArgString$ & mavFuncsCalled(FuncList%, 1 + i%) & ", "
               End If
            Next i%
            If Len(ArgString$) > 1 Then ArgString$ = Left$(ArgString$, Len(ArgString$) - 2)
            HistoryText$ = HistoryText$ & LibFunction$ & vbCrLf
            HistoryText$ = HistoryText$ & ArgString$ & vbCrLf
            HistoryText$ = HistoryText$ & "Handle: " & ReturnVal$ & vbCrLf & vbCrLf
         Case InByte, InWord
            If gnHexVals And (VarType(mavFuncsCalled(FuncList%, 1 + i%)) < 4) Then
               ReturnVal$ = "0x" & Hex$(mavFuncsCalled(FuncList%, 1))
            Else
               ReturnVal$ = mavFuncsCalled(FuncList%, 1)
            End If
            LibFunction$ = GetFunctionString(FuncID%)
            ArgString$ = "Arg Vals: "
            For i% = 1 To NumArgs%
               If gnHexVals And (VarType(mavFuncsCalled(FuncList%, 1 + i%)) < 4) Then
                  ArgString$ = ArgString$ & "0x" & Hex$(mavFuncsCalled(FuncList%, 1 + i%)) & ", "
               Else
                  ArgString$ = ArgString$ & mavFuncsCalled(FuncList%, 1 + i%) & ", "
               End If
            Next i%
            If Len(ArgString$) > 1 Then ArgString$ = Left$(ArgString$, Len(ArgString$) - 2)
            HistoryText$ = HistoryText$ & LibFunction$ & vbCrLf
            HistoryText$ = HistoryText$ & ArgString$ & vbCrLf
            HistoryText$ = HistoryText$ & "Port Value: " & ReturnVal$ & vbCrLf & vbCrLf
         Case Else
            If FuncID% = -1 Then
               LibFunction$ = SavedFunction
               ErrMessage$ = mavFuncsCalled(FuncList%, 2)
               MsgResponse$ = mavFuncsCalled(FuncList%, 3)
               HistoryText$ = HistoryText$ & LibFunction$ & vbCrLf & MsgResponse$ & vbCrLf
               HistoryText$ = HistoryText$ & ErrMessage$ & vbCrLf & vbCrLf
               If (Not ErrMessage$ = "No errors occurred.") And gnScriptRun And (Not Reported%) Then
                  FailStart$ = "¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯" & vbCrLf & _
                  "*****   Unexpected MBD Error during script run:   *****" & vbCrLf & vbCrLf
                  EndFlag$ = "________________________________________________" & vbCrLf
                  If gnPrintEval Then frmScriptInfo.txtScriptInfo.Text = frmScriptInfo.txtScriptInfo.Text & _
                  FailStart$ & LibFunction$ & vbCrLf & "Error " & ErrMessage$ & _
                  " (" & ErrConst$ & "):  " & ErrMessage$ & vbCrLf & EndFlag$
                  If gnPauseEval Then gnErrFlag = True
                  Reported% = True
               End If
            Else
               ErrCode = mavFuncsCalled(FuncList%, 1)
               LibFunction$ = GetFunctionString(FuncID%)
               ArgString$ = "Arg Vals: "
               For i% = 1 To NumArgs%
                  If gnHexVals And (VarType(mavFuncsCalled(FuncList%, 1 + i%)) < 4) Then
                     If IsNull(mavFuncsCalled(FuncList%, 1 + i%)) Then
                        ArgString$ = ArgString$ & "Null, "
                     Else
                        ArgString$ = ArgString$ & "0x" & Hex$(mavFuncsCalled(FuncList%, 1 + i%)) & ", "
                     End If
                  Else
                     ArgString$ = ArgString$ & mavFuncsCalled(FuncList%, 1 + i%) & ", "
                  End If
               Next i%
               If Len(ArgString$) > 1 Then ArgString$ = Left$(ArgString$, Len(ArgString$) - 2)
               If ErrCode < -255 Then
                  ErrMessage$ = "Data contains values that " & _
                    "are not numbers, infinite, or out of range."
                  If gnPauseEval Then gnErrFlag = True
               Else
                  ErrMessage$ = Space$(ERRSTRLEN)  'ERRSTRLEN
                  If gnLibType = NETLIB Then
                     If ErrCode = -1 Then
                        'to do net
                        'ErrMessage$ = NetLibrary
                        ErrMessage$ = "Internal Net Interface Error"
                     End If
                  Else
                     ULStat = cbGetErrMsg(ErrCode, ErrMessage$)
                  End If
               End If
               If ULStat = CFGFILENOTFOUND Then
                  'MsgBox "CB.CFG configuration file not found.  Rerun Instacal", , "Fatal Error"
                  HistoryText$ = "CB.CFG configuration file not found.  Rerun Instacal"
                  Exit Do
               ElseIf ULStat <> 0 And geErrFlow <> 0 Then
                  HistoryText$ = "Error reading error message"
                  Exit Do
               Else
                  ErrMessage$ = RTrim$(ErrMessage$)
                  If Len(ErrMessage$) > 0 Then ErrMessage$ = Left$(ErrMessage$, Len(ErrMessage$) - 1)
                  HistoryText$ = HistoryText$ & LibFunction$ & vbCrLf
                  HistoryText$ = HistoryText$ & ArgString$ & vbCrLf
                  ThisError$ = ErrCode
                  If gnHexVals Then ThisError$ = "0x" & Hex$(ErrCode)
                  ErrConst$ = GetErrorConst(ErrCode)
                  HistoryText$ = HistoryText$ & "Error " & ThisError$ & " (" & ErrConst$ & "):  " & _
                  ErrMessage$ & vbCrLf & vbCrLf
               End If
            End If
            If gnScriptRun And (ErrCode <> 0) And Not Reported% Then
               FailStart$ = "¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯" & vbCrLf & _
               "*****   Unexpected UL Error during script run:   *****" & vbCrLf & vbCrLf
               EndFlag$ = "________________________________________________" & vbCrLf
               If gnPrintEval Then frmScriptInfo.txtScriptInfo.Text = frmScriptInfo.txtScriptInfo.Text & _
               FailStart$ & LibFunction$ & vbCrLf & ArgString$ & vbCrLf & "Error " & ThisError$ & _
               " (" & ErrConst$ & "):  " & ErrMessage$ & vbCrLf & EndFlag$
               If gnPauseEval Then
                  'If (mnCurrentMode = mRUNNING) And Not mnStepping Then cmdScript_Click (5)
                  gnErrFlag = True
               End If
               Reported% = True
            End If
      End Select
      'If FuncList% = gnCurFunc - 1 Then
      '   If gnShowComments And (Len(HistoryText$) > 2) Then
      '      Separator$ = "***************************" & vbCrLf
      '      frmScriptInfo.txtScriptInfo.Text = frmScriptInfo.txtScriptInfo.Text & Separator$ & Left(HistoryText$, Len(HistoryText$) - 2) & Separator$
      '   End If
      'End If
   Loop While FuncList% <> gnCurFunc
   GetHistoryText = HistoryText$

End Function

Function GetMaxFuncs() As Integer
   
   GetMaxFuncs = mMaxFuncs

End Function

Function GetNumArgs(FuncID As Integer) As Integer

   Select Case FuncID
      Case AConvertData
         NumArgs% = 4
      Case ACalibrateData
         NumArgs% = 4
      Case AConvertPretrigData
         NumArgs% = 5
      Case AIn
         NumArgs% = 7
      Case AInScan
         NumArgs% = 8
      Case ALoadQueue
         NumArgs% = 4
      Case AOut
         NumArgs% = 4
      Case AOutScan
         NumArgs% = 8
      Case APretrig
         NumArgs% = 9
      Case ATrig
         NumArgs% = 6
      Case C8254Config
         NumArgs% = 3
      Case C8536Config
         NumArgs% = 5
      Case C9513Config
         NumArgs% = 11
      Case C8536Init
         NumArgs% = 3
      Case C9513Init
         NumArgs% = 7
      Case CStoreOnInt
         NumArgs% = 5
      Case CFreqIn
         NumArgs% = 5
      Case CIn
         NumArgs% = 3
      Case CLoad
         NumArgs% = 3
      Case DBitIn
         NumArgs% = 4
      Case DBitOut
         NumArgs% = 4
      Case DConfigPort
         NumArgs% = 3
      Case DeclareRevision
         NumArgs% = 1
      Case DIn
         NumArgs% = 3
      Case DInScan
         NumArgs% = 6
      Case DOut
         NumArgs% = 3
      Case DOutScan
         NumArgs% = 6
      Case ErrHandling
         NumArgs% = 2
      Case FileAInScan
         NumArgs% = 8
      Case FileGetInfo
         NumArgs% = 7
      Case FilePretrig
         NumArgs% = 9
      Case FileRead
         NumArgs% = 4
      Case GetErrMsg
         NumArgs% = 2
      Case GetRevision
         NumArgs% = 2
      Case GetStatus
         If WIN32APP And (CURRENTREVNUM > 5.19) Then
            NumArgs% = 5
         Else
            NumArgs% = 4
         End If
      Case StopBackground
         If WIN32APP And (CURRENTREVNUM > 5.19) Then
            NumArgs% = 2
         Else
            NumArgs% = 1
         End If
      Case MemSetDTMode
         NumArgs% = 2
      Case MemReset
         NumArgs% = 1
      Case MemRead
         NumArgs% = 4
      Case MemWrite
         NumArgs% = 4
      Case MemReadPretrig
         NumArgs% = 4
      Case RS485
         NumArgs% = 3
      Case TIn
         NumArgs% = 5
      Case TInScan
         NumArgs% = 6
      Case WinBufToArray
         NumArgs% = 4
      Case WinArrayToBuf
         NumArgs% = 4
      Case WinBufAlloc
         NumArgs% = 1
      Case WinBufFree
         NumArgs% = 1
      Case InByte
         NumArgs% = 2
      Case OutByte
         NumArgs% = 3
      Case InWord
         NumArgs% = 2
      Case OutWord
         NumArgs% = 3
      Case GetConfig
         NumArgs% = 5
      Case SetConfig
         NumArgs% = 5
      Case ToEngUnits
         NumArgs% = 4
      Case FromEngUnits
         NumArgs% = 4
      Case GetBoardName
         NumArgs% = 2
      Case SetTrigger
         NumArgs% = 4
      Case LoadConfig
         NumArgs% = 1
      Case SaveConfig
         NumArgs% = 1
      Case C7266Config
         NumArgs% = 9
      Case CIn32
         NumArgs% = 3
      Case CLoad32
         NumArgs% = 3
      Case CStatus
         NumArgs% = 3
      Case EnableEvent
         NumArgs% = 5
      Case DisableEvent
         NumArgs% = 2
      Case CallbackFunc
         NumArgs% = 4
      Case GetSubSystemStatus
         NumArgs% = 5
      Case StopSubSystemBackground
         NumArgs% = 2
      Case DConfigBit
         NumArgs% = 4
      Case SelectSignal
         NumArgs% = 5
      Case GetSignal
         NumArgs% = 6
      Case FlashLED
         NumArgs% = 1
      Case LogGetFileName
         NumArgs% = 3
      Case LogGetFileInfo
         NumArgs% = 3
      Case LogGetSampleInfo
         NumArgs% = 5
      Case LogGetAIInfo
         NumArgs% = 4
      Case LogGetCJCInfo
         NumArgs% = 2
      Case LogGetDIOInfo
         NumArgs% = 2
      Case LogReadTimeTags
         NumArgs% = 5
      Case LogReadAIChannels
         NumArgs% = 4
      Case LogReadCJCChannels
         NumArgs% = 4
      Case LogReadDIOChannels
         NumArgs% = 4
      Case LogConvertFile
         NumArgs% = 6
      Case LogSetPreferences
         NumArgs% = 3
      Case LogGetPreferences
         NumArgs% = 3
      Case LogGetAIChannelCount
         NumArgs% = 2
      Case CInScan
         NumArgs% = 7
      Case CConfigScan
         NumArgs% = 8
      Case CClear
         NumArgs% = 2
      Case TimerOutStart
         NumArgs% = 3
      Case TimerOutStop
         NumArgs% = 2
      Case WinBufAlloc32
         NumArgs% = 1
      Case WinBufToArray32
         NumArgs% = 4
      Case DaqInScan
         NumArgs% = 10
      Case DaqSetTrigger
         NumArgs% = 9
      Case DaqOutScan
         NumArgs% = 9
      Case GetTCValues
         NumArgs% = 9
      Case VIn
         NumArgs% = 5
      Case GetConfigString '= 106
         NumArgs% = 6
      Case SetConfigString '= 107
         NumArgs% = 6
      Case VOut            '= 108
         NumArgs% = 5
      Case DaqSetSetpoints '= 109
         NumArgs% = 11
      Case DeviceLogin     '= 110
         NumArgs% = 3
      Case DeviceLogout    '= 111
         NumArgs% = 1
      Case PulseOutStart   '112
         NumArgs% = 8
      Case PulseOutStop    '113
         NumArgs% = 2
      Case AIn32           '114
         NumArgs% = 8
      Case ToEngUnits32    '= 115
         NumArgs% = 4
      Case VIn32    '= 116
         NumArgs% = 8
      Case WinBufAlloc64   '117
         NumArgs% = 1
      Case ScaledWinBufToArray '118
         NumArgs% = 4
      Case ScaledWinBufAlloc '119
         NumArgs% = 1
      Case TEDSRead  '120
         NumArgs% = 5
      Case ScaledWinArrayToBuf  '121
         NumArgs% = 4
      Case CIn64     '122
         NumArgs% = 3
      Case CLoad64   '123
         NumArgs% = 3
      Case WinBufToArray64 '124
         NumArgs% = 4
      Case IgnoreInstaCal '125
         NumArgs% = 0
      Case GetDaqDeviceInventory '126
         NumArgs% = 3
      Case CreateDaqDevice '127
         NumArgs% = 2
      Case ReleaseDaqDevice '128
         NumArgs% = 1
      Case GetBoardNumber '129
         NumArgs% = 1
      Case GetNetDeviceDescriptor '130
         NumArgs% = 4
      Case AInputMode '131
         NumArgs% = 2
      Case AChanInputMode '132
         NumArgs% = 3
      Case WinArrayToBuf32 '133
         NumArgs% = 4
      Case DInArray   '134
         NumArgs% = 4
      Case DOutArray   '135
         NumArgs% = 4
      Case DaqDeviceVersion   '136
         NumArgs% = 3
      Case DIn32        '137
         NumArgs% = 3
      Case DOut32        '138
         NumArgs% = 3
      Case DClearAlarm  '139
         NumArgs% = 3
         
      Case GPFind
         NumArgs% = 1
      Case GPSend
         NumArgs% = 5
      Case GPReceive
         NumArgs% = 1
      Case GPTrigger
         NumArgs% = 1
      Case GPDevClear
         NumArgs% = 2
      Case GPIBAsk
         NumArgs% = 1
      Case GPInit
         NumArgs% = 1
      Case GPPtrs
         NumArgs% = 1
      Case GPSelDevClear
         NumArgs% = 1
      Case GPSre
         NumArgs% = 1
      
      Case SSetBoardName
         NumArgs% = 1
      Case SShowDiag
         NumArgs% = 6
      Case SContPlot
         NumArgs% = 1
      Case SConvData
         NumArgs% = 1
      Case SConvPT
         NumArgs% = 1
      Case SSetData
         NumArgs% = 1
      Case SSetAmplitude
         NumArgs% = 1
      Case SSetOffset
         NumArgs% = 1
      Case SCalCheck
         NumArgs% = 1
      Case SCountSet
         NumArgs% = 1
      Case SAddPTBuf
         NumArgs% = 1
      Case SSetDevName
         NumArgs% = 1
      Case SSetPlotOpts ' = 2012
         NumArgs% = 2
      Case SBufInfo     ' = 2013
         NumArgs% = 0
      Case SSetPlotChan ' = 2014
         NumArgs% = 1
      Case SNextBlock '2015
         NumArgs% = 1
      Case SSetBlock  '2016
         NumArgs% = 2
      Case SSetResolution '= 2018
         NumArgs% = 1
      Case SShowText  '2019
         NumArgs% = 1
      Case SGetTC     '2020
         NumArgs% = 1
      Case SToEng     '2021
         NumArgs% = 1
      Case SPlotType    '2022
         NumArgs% = 1
      Case SCalcNoise   '2023
         NumArgs% = 1
      Case SLogOutput   '2024
         NumArgs% = 3
      Case SLoadStringList '2025
         NumArgs% = 2
      Case SGetStringFromList
         NumArgs% = 2
      Case SSetPlotScaling    '2027
         NumArgs% = 1
      Case SSetFirstPlotPoint
         NumArgs% = 1
      Case SLoadCSVList       '2029
         NumArgs% = 3
      Case SEvalData '2030
         NumArgs% = 5
      Case SEvalEnable  '2031
         NumArgs% = 1
      Case SEvalDelta   '2032
         NumArgs% = 1
      Case SGetCSVsFromList '2033
         NumArgs% = 3
      Case SCopyFile '2036
         NumArgs% = 2
      Case SRunApp '2037
         NumArgs% = 2
      Case SEndApp '2038
         NumArgs% = 0
      Case SGetFormRef  '2041
         NumArgs% = 1
      Case SSelPortRange   '2042
         NumArgs% = 2
      Case SSetPortDirection  '2043
         NumArgs% = 1
      Case SReadPortRange  '2044
         NumArgs% = 1
      Case SWritePortRange '2045
         NumArgs% = 2
      Case SSelBitRange   '2046
         NumArgs% = 2
      Case SReadBitRange   '2047
         NumArgs% = 1
      Case SWriteBitRange  '2048
         NumArgs% = 1
      Case SGenerateData   '2049
         NumArgs% = 10
      Case SPlotGenData    '2050
         NumArgs% = 0
      Case SPlotAcqData    '2051
         NumArgs% = 0
      Case SSetBitDirection '2052
         NumArgs% = 1
      Case SWaitForIdle '2053
         NumArgs% = 2
      Case SWaitForEvent '2054
         NumArgs% = 3
      Case SWaitStatusChange  '2055
         NumArgs% = 3
      Case SStopOnCount  '2056
         NumArgs% = 2
      Case SPlotOnCount  '2057
         NumArgs% = 2
      Case SSetBitsPerPort  '2058
         NumArgs% = 3
      Case SCounterArm   '2060
         NumArgs% = 3
      
      Case SDelay '3000
         NumArgs% = 1
      Case SErrorPrint  '3001
         NumArgs% = 1
      Case SGetStatus   '3002
         NumArgs% = 1
      Case SErrorFlow   '3003
         NumArgs% = 1
      Case SULErrFlow   '3004
         NumArgs% = 1
      Case SULErrReport   '3005
         NumArgs% = 1
      Case SSetStaticOption   '3006
         NumArgs% = 2
      Case SScriptRate    '3008
         NumArgs% = 1
      Case SSetVariable    '3009
         NumArgs% = 3
      Case SGetFormProps   '3010
         NumArgs% = 2
      Case SGetStaticOptions  '3011
         NumArgs% = 0
      Case SSetFormProps   '3012
         NumArgs% = 2
      Case SCloseApp    '3013
         NumArgs% = 0
      Case SSetVarDefault  '3014
         NumArgs% = 2
      Case SPauseScript    '3015
         NumArgs% = 1
      Case SGetParameterString    '3016
         NumArgs% = 3
      Case SPicklist       '3017
         NumArgs% = 5
      Case SGenRndVal      '3018
         NumArgs% = 2
      Case SPickGroup      '3019
         NumArgs% = 5
      Case SSetLibType     '3020
         NumArgs% = 1
      Case SCalcMaxSinDelta   '3021
         NumArgs% = 5
      Case SIsListed   '3022
         NumArgs% = 5
      Case SPeriodCalc   '3023
         NumArgs% = 2
      Case SPulseWidthCalc '3024
         NumArgs% = 1
      Case SMapAISwitch    '3025
         NumArgs% = 2
      Case SStopScript    '3026
         NumArgs% = 1
      Case SSetMCCControl  '3027
         NumArgs% = 1
      Case SGetDP8200Cmd  '3028
         NumArgs% = 2
      Case SEvalParamRev  '3029
         NumArgs% = 2

      Case SLoadSubScript '4001
         NumArgs% = 2
      Case SCloseSubScript '4002
         NumArgs% = 0
      Case SOpenWindow '5001    'open window in scripter
         NumArgs% = 2
      Case SCloseWindow '5002   'close window in scripter
         NumArgs% = 1

      Case WinAPIGlobalAlloc    '&H1001
         NumArgs% = 2
      Case WinAPIGlobalFree     '&H1002
         NumArgs% = 1
      Case WinAPICreateFileMapping      '&H1003
         NumArgs% = 6
      Case WinAPIMapViewOfFile  '&H1004
         NumArgs% = 5
      Case WinAPIUnmapViewOfFile        '&H1005
         NumArgs% = 1
      Case WinAPIOpenFileMapping        '&H1006
         NumArgs% = 3

      Case USBBlink '= 8001
         NumArgs% = 1
      Case USBReset '= 8002
         NumArgs% = 1
      Case USBGetSerialNum '= 8003
         NumArgs% = 2
      Case USBSetSerialNum '= 8004
         NumArgs% = 2
      Case USBMemRead '= 8005
         NumArgs% = 4
      Case USBMemWrite '= 8006
         NumArgs% = 4
      Case USBWatchdog '= 8007
         NumArgs% = 6
      Case USBAInScan ' 8008
         NumArgs% = 8
      Case USBALoadQueue ' 8009
         NumArgs% = 4
      Case USBAIn ' 8010
         NumArgs% = 4
      Case USBAOut '= 8011
         NumArgs% = 4
      Case USBDConfigPort '= 8012
         NumArgs% = 3
      Case USBDIn '= 8013
         NumArgs% = 3
      Case USBDOut '= 8014
         NumArgs% = 3
      Case USBDBitIn '= 8015
         NumArgs% = 4
      Case USBDBitOut '= 8016
         NumArgs% = 4
      Case USBGetStatus '= 8017
         NumArgs% = 4
      Case USBGetErrMsg '= 8018
         NumArgs% = 2
      Case USBDConfigBit '= 8019
         NumArgs% = 4
      Case USBStopBackground '= 8021
         NumArgs% = 1
      Case USBCInit '= 8022
         NumArgs% = 1
      Case USBCIn32 '= 8023
         NumArgs% = 3
      Case USBFromEngUnits '= 8024
         NumArgs% = 4
      Case USBToEngUnits '= 8025
         NumArgs% = 4
      Case USBDSetTrig '= 8026
         NumArgs% = 3
      Case USBSaveConfig '= 8027
         NumArgs% = 1
      Case EStatus   '10001
         NumArgs% = 4
      Case ETimeStamp '10002
         NumArgs% = 0
      Case EEventType   '10003
         NumArgs% = 5
      Case EDataDC   '10010
         NumArgs% = 4
      Case EDataPulse   '10011
         NumArgs% = 9
      Case EDataDelta   '10012
         NumArgs% = 5
      Case EDataAmplitude  '10013
         NumArgs% = 5
      Case SEvalTrigPoint  '10015
         NumArgs% = 7
      Case EDataTime '10021
         NumArgs% = 7
      Case EDataOutVsIn '10022
         NumArgs% = 5
      Case EDataSkew '10023
         NumArgs% = 6
      Case EData32Delta    '10030
         NumArgs% = 5
      Case EError
         NumArgs% = 6
      Case EHistogram   '10051
         NumArgs% = 5
      Case EStore488Value '10052
         NumArgs% = 0
      Case ECompareStoredValue '10053
         NumArgs% = 3
   End Select
   GetNumArgs = NumArgs%

End Function

Function SaveFunc(CallingForm As Form, FuncID As Integer, FuncStat, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, AuxHandle) As Integer

   If mnFunctionHistory = 0 Then SetHistory 10, 0
   If (FuncID > mMaxFuncs) Or (FuncID < 0) Then
      DontStore% = True
      If FuncID > &H1000 Then DontStore% = False
   Else
      DontStore% = mnFuncList(FuncID)
   End If
   
   If Not DontStore% Then
      mavFuncsCalled(gnCurFunc, 0) = FuncID
      mavFuncsCalled(gnCurFunc, 1) = FuncStat
      mavFuncsCalled(gnCurFunc, 14) = AuxHandle
      NumArgs% = GetNumArgs(FuncID)
      'If FuncID = 2 Then Stop
      'USB-1608HS causes div by 0 error if Rate = 0 with xclock when in IDE
      'logged as part of bug 3374
      For i% = 1 To NumArgs%
         CurArg = Choose(i%, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
         If IsNumeric(CurArg) Then
            If CurArg = 0 Then
               CurArgString$ = Format(CurArg, "0")
               If Not Val(CurArgString$) = 0 Then
                  CurArg = "Val? [" & CurArgString$ & "]"
                  'CurArg is infinity or not a number
                  FuncStat = -256
                  mavFuncsCalled(gnCurFunc, 1) = FuncStat
               End If
            Else
               TempArg = Fix(CurArg)
               If Abs(TempArg) < 922337203685477# Then
                  If ((CurArg - 1) = CurArg) Then
                     'CurArg is infinity or not a number
                     CurArg = "Val? [" & Str(CurArg) & "]"
                     FuncStat = -256
                     mavFuncsCalled(gnCurFunc, 1) = FuncStat
                  End If
               End If
            End If
         End If
         mavFuncsCalled(gnCurFunc, i% + 1) = CurArg
         If Not IsEmpty(CurArg) Then Argument$ = Argument$ & Filler$ & CurArg
         Filler$ = ", "
      Next i%
      DDEFuncIndex% = gnCurFunc
      gnCurFunc = gnCurFunc + 1
      If gnCurFunc = mnFunctionHistory - 1 Then
         If mnHistoryFile = SAVEALL Then
            HistoryText$ = GetHistoryText()
            Print #1, "********************"
            Print #1, Now
            Print #1, "********************"
            Print #1,
            Print #1, HistoryText$
         End If
         gnCurFunc = 0
      End If
   End If
   
   Select Case FuncID
      'handles cases where the function returns data rather than an error code
      Case WinBufAlloc, WinBufAlloc32, WinBufAlloc64, ScaledWinBufAlloc
         If FuncStat = 0 Then
            If gnLocalErrDisp Then ErrorHandling
            If geErrFlow = 2 Then StopError% = True
            If geErrFlow = 1 Then SaveFunc = True
            ErrorDetect% = True
         End If
      Case InByte, InWord, LoadConfig
         'Exit Function
      Case Else
         ErrorOccurred% = ((FuncStat <> 0) And (FuncStat <> TOOFEW))
         If ErrorOccurred% Or gnLiveDisp Then
            If mnThreading Then mnThreadState = TS_ERROR
            If gnScriptRun Then
               ErrorVal& = FuncStat
               frmScript.SetULError ErrorVal&
            End If
            If geErrFlow = 1 Then
                'gnCancel = True
               If (Not CallingForm Is Nothing) And ErrorOccurred% Then
                  CallingForm.cmdConfigure.Caption = "q1"
                  CallingForm.cmdConfigure = True
               End If
               SaveFunc = ErrorOccurred%
            End If
            If (mnHistoryFile = SAVEERRORS) And gnLocalErrDisp Then
               HistoryText$ = GetHistoryText()
               Print #1, "********************"
               Print #1, Now
               Print #1, "********************"
               Print #1,
               Print #1, HistoryText$
            End If
            If Not DontStore% Then
               If gnLocalErrDisp Then ErrorHandling Not ErrorOccurred%
               If geErrFlow = 2 Then StopError% = ErrorOccurred%
               ErrorDetect% = ErrorOccurred%
            End If
         End If
   End Select
   If (mnHistoryFile = SAVEALL) And Not (mnHistoryFile = SAVEERRORS) Then
      HistoryText$ = GetHistoryText()
      Print #1, "********************"
      Print #1, Now
      Print #1, "********************"
      Print #1,
      Print #1, HistoryText$
   End If
   If gnScriptSave And (FuncStat = 0) Then
      Select Case FuncID
         Case AIn To FileAInScan, FilePretrig To DOutScan, InByte To SetTrigger, LoadConfig, SetConfig, GetStatus
            For ArgNum% = 1 To 14
               ArgVar = Choose(ArgNum%, CallingForm.Tag, FuncID, FuncStat, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
               If IsNull(ArgVar) Or IsEmpty(ArgVar) Then
                  PrintString$ = PrintString$ & ", "
               Else
                  PrintString$ = PrintString$ & Format$(ArgVar, "") & ", "
               End If
            Next
            Print #2, PrintString$; Format$(AuxHandle, "0")
         Case StopBackground, CIn32, CLoad32, EnableEvent, DisableEvent, DConfigBit To GetSignal
            For ArgNum% = 1 To 14
               ArgVar = Choose(ArgNum%, CallingForm.Tag, FuncID, FuncStat, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
               If IsNull(ArgVar) Or IsEmpty(ArgVar) Then
                  PrintString$ = PrintString$ & ", "
               Else
                  PrintString$ = PrintString$ & Format$(ArgVar, "") & ", "
               End If
            Next
            Print #2, PrintString$; Format$(AuxHandle, "0")
         Case CInScan To TimerOutStop, DaqInScan To VIn, VOut To ToEngUnits32, GPFind To GPReceive, SShowText, SGetTC To SCalcNoise, USBBlink To USBDSetTrig
            For ArgNum% = 1 To 14
               ArgVar = Choose(ArgNum%, CallingForm.Tag, FuncID, FuncStat, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
               If IsNull(ArgVar) Or IsEmpty(ArgVar) Then
                  PrintString$ = PrintString$ & ", "
               Else
                  PrintString$ = PrintString$ & Format$(ArgVar, "") & ", "
               End If
            Next
            Print #2, PrintString$; Format$(AuxHandle, "0")
      End Select
      'not logged: FileGetInfo, AConvertData, ACalibrateData, AConvertPretrigData,
      'ToEngUnits, FromEngUnits, FileRead, MemSetDTMode, MemReset, MemRead,
      'MemWrite, MemReadPretrig, RS485, WinBufToArray, WinArrayToBuf, WinBufAlloc, WinBufFree,
      'DeclareRevision, GetRevision, GetBoardName, GetConfig, SetConfig, GetErrMsg,
      'ErrHandling, GetStatus, StopBackground, AddBoard, AddExp, AddMem, AIGetPcmCalCoeffs,
      'CreateBoard, DeleteBoard, SaveConfig, C7266Config, CIn32, CLoad32, CStatus,
      'CallbackFunc, GetSubSystemStatus, StopSubSystemBackground, FlashLED,
      'LogGetFileName, LogGetFileInfo, LogGetSampleInfo, LogGetAIInfo, LogGetCJCInfo,
      'LogGetDIOInfo, LogReadTimeTags, LogReadAIChannels, LogReadCJCChannels, LogReadDIOChannels,
      'LogConvertFile, LogSetPreferences, LogGetPreferences, LogGetAIChannelCount,
      'GetConfigString, SetConfigString, DaqSetSetpoints

      'WinBufAlloc32, WinBufToArray32, WinBufAlloc64
      
   End If
'   Global Const C7266Config = 67
'   Global Const CIn32 = 68
'   Global Const CLoad32 = 69
'   Global Const CStatus = 70
'   Global Const CallbackFunc = 73
'   Global Const GetSubSystemStatus = 74
'   Global Const StopSubSystemBackground = 75
   If StopError% Then
      If gnIDERunning Then
         Stop
      Else
         Dim Resp As VbMsgBoxResult
         Resp = MsgBox("This path is a Stop statement " & _
         "in the IDE. Check Local Error Handling options. " _
         & vbCrLf & vbCrLf & "          Click Yes to attempt " & _
         "to continue, No to exit application.", _
         vbYesNo, "Attempt To Continue?")
         If Resp = vbNo Then End
      End If
   End If
   
End Function

Function SaveMsg(CallingForm As Form, MsgFunc As String, MsgResponse As String) As Integer

   SaveMsg = False
   If Not CallingForm Is Nothing Then BoardName$ = CallingForm.GetMsgDevice()
   If mnFunctionHistory = 0 Then SetHistory 10, 0
   'check message for bad characters
   ChrsReturned& = Len(MsgResponse)
   For Character& = 1 To ChrsReturned&
      AscValue% = Asc(Mid(MsgResponse, Character&, 1))
      ChrList$ = ChrList$ & Format(AscValue%, "0") & " "
      If AscValue% < 32 Then
         BadString$ = BadString$ & "_"
         MsgError% = True
      Else
         BadString$ = BadString$ & Chr(AscValue%)
      End If
   Next
   If MsgError% Then MsgBox "Corrupt message returned." & vbCrLf & BadString$ & vbCrLf & ChrList$
   If Left(MsgResponse, 7) = "Warning" Then MsgWarning% = True
   If Left(MsgResponse, 5) = "Error" Then MsgError% = True
   If MsgError% And (MsgWarning% Or gnLocalWarnDisp) Then
      FuncStat = True
      mavFuncsCalled(gnCurFunc, 2) = MsgResponse
      mavFuncsCalled(gnCurFunc, 3) = BoardName$ & " Response:  Error"
   Else
      FuncStat = False
      mavFuncsCalled(gnCurFunc, 2) = "No errors occurred."
      mavFuncsCalled(gnCurFunc, 3) = BoardName$ & " Response:  " & MsgResponse
   End If
   mavFuncsCalled(gnCurFunc, 0) = MsgFunc
   mavFuncsCalled(gnCurFunc, 1) = FuncStat
   gnCurFunc = gnCurFunc + 1
   If gnCurFunc = mnFunctionHistory - 1 Then  '- 1
      If mnHistoryFile = SAVEALL Then
         HistoryText$ = GetHistoryText()
         Print #1, "********************"
         Print #1, Now
         Print #1, "********************"
         Print #1,
         Print #1, HistoryText$
      End If
      gnCurFunc = 0
   End If
   ErrorOccurred% = (FuncStat <> 0) And (FuncStat <> TOOFEW)
   If ErrorOccurred% Or gnLiveDisp Then
      If mnThreading Then mnThreadState = TS_ERROR
      If gnScriptRun Then
         ErrorVal& = FuncStat
         frmScript.SetULError ErrorVal&
      End If
      Abort% = (geErrFlow = 1) And MsgError%
      Abort% = Abort% Or ((geWarnFlow = 1) And MsgWarning%)
      If Abort% Then
         If (Not CallingForm Is Nothing) And MsgError% Then
            CallingForm.cmdConfigure.Caption = "q1"
            CallingForm.cmdConfigure = True
         End If
         SaveMsg = True
      End If
      If (mnHistoryFile = SAVEERRORS) And gnLocalErrDisp Then
         HistoryText$ = GetHistoryText()
         Print #1, "********************"
         Print #1, Now
         Print #1, "********************"
         Print #1,
         Print #1, HistoryText$
      End If
      If Not DontStore% Then
         If gnLocalErrDisp Then ErrorHandling
         If geErrFlow = 2 Then StopError% = MsgError%
         If geWarnFlow = 2 Then StopError% = MsgError%
         ErrorDetect% = MsgError%
         SaveMsg = MsgError%
      End If
   End If
   If (mnHistoryFile = SAVEALL) And Not (mnHistoryFile = SAVEERRORS) Then
      HistoryText$ = GetHistoryText()
      Print #1, "********************"
      Print #1, Now
      Print #1, "********************"
      Print #1,
      Print #1, HistoryText$
   End If
   If StopError% Then
      If gnIDERunning Then
         Stop
      Else
         Dim Resp As VbMsgBoxResult
         Resp = MsgBox("This path is a Stop statement " & _
         "in the IDE. Check Local Error Handling options. " _
         & vbCrLf & vbCrLf & "          Click Yes to attempt " & _
         "to continue, No to exit application.", _
         vbYesNo, "Attempt To Continue?")
         If Resp = vbNo Then End
      End If
   End If
   
End Function

Sub SetFuncsSaved(FuncList() As Integer)

   LastFunc% = UBound(FuncList)
   If UBound(FuncList) > mMaxFuncs Then LastFunc% = mMaxFuncs
   For i% = 1 To LastFunc%
      mnFuncList(i%) = FuncList(i%)
      If FuncList(i%) Then
         FuncStat$ = FuncStat$ & "1"
      Else
         FuncStat$ = FuncStat$ & "0"
      End If
   Next i%

   lpFileName$ = "UniTest.ini"
   lpApplicationName$ = "HistBuffer"
   lpKeyName$ = "BufferedFuncs"
   lpString$ = FuncStat$
   x% = WritePrivateProfileString(lpApplicationName$, lpKeyName$, lpString$, lpFileName$)

End Sub

Sub SetHistory(NumFuncs As Integer, FileMode As Integer)

   Dim NoForm As Form
   
   If mnFunctionHistory = NumFuncs Then
      FuncStat = 1
   Else
      If Not NumFuncs = -1 Then mnFunctionHistory = NumFuncs
      FuncStat = 0
   End If
   AlreadyOpen% = (mnHistoryFile = FileMode)
   mnHistoryFile = FileMode
   If mnHistoryFile = 0 Then
      Close #1
   Else
      If Not AlreadyOpen% Then Open "FuncHist.txt" For Output As #1
      x% = SaveFunc(NoForm, -1, FuncStat, 0, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, 0)
   End If
   ReDim mavFuncsCalled(mnFunctionHistory - 1, 14)

   lpFileName$ = "UniTest.ini"
   lpApplicationName$ = "HistBuffer"
   lpKeyName$ = "BufferSize"
   lpString$ = Str$(mnFunctionHistory)
   x% = WritePrivateProfileString(lpApplicationName$, lpKeyName$, lpString$, lpFileName$)

   lpApplicationName$ = "frmScriptInfo"
   lpKeyName$ = "Comments"
   nSize% = 12
   lpReturnedString$ = Space$(nSize%)
   lpDefault$ = Environ("Disabled")
   x% = GetPrivateProfileString(lpApplicationName$, lpKeyName$, lpDefault$, lpReturnedString$, nSize%, lpFileName$)
   CommentStatus$ = Left$(lpReturnedString$, x%)
   If Len(CommentStatus$) Then
      If CommentStatus$ = "Enabled" Then gnShowComments = True
   End If

   lpKeyName$ = "PrintEval"
   nSize% = 12
   lpReturnedString$ = Space$(nSize%)
   lpDefault$ = Environ("Disabled")
   x% = GetPrivateProfileString(lpApplicationName$, lpKeyName$, lpDefault$, lpReturnedString$, nSize%, lpFileName$)
   PrintStat$ = Left$(lpReturnedString$, x%)
   If Len(PrintStat$) Then
      If PrintStat$ = "Enabled" Then gnPrintEval = True
   End If

   lpKeyName$ = "PauseEval"
   nSize% = 12
   lpReturnedString$ = Space$(nSize%)
   lpDefault$ = Environ("Disabled")
   x% = GetPrivateProfileString(lpApplicationName$, lpKeyName$, lpDefault$, lpReturnedString$, nSize%, lpFileName$)
   PauseStat$ = Left$(lpReturnedString$, x%)
   If Len(PauseStat$) Then
      If PauseStat$ = "Enabled" Then gnPauseEval = True
   End If

   lpKeyName$ = "PrintAllEval"
   nSize% = 12
   lpReturnedString$ = Space$(nSize%)
   lpDefault$ = Environ("Disabled")
   x% = GetPrivateProfileString(lpApplicationName$, lpKeyName$, lpDefault$, lpReturnedString$, nSize%, lpFileName$)
   PrintAllStat$ = Left$(lpReturnedString$, x%)
   If Len(PrintAllStat$) Then
      If PrintAllStat$ = "Enabled" Then gnPrintEvalAll = True
   End If

End Sub

Public Function FindFunctionError(ULFunction As Integer, Arguments As String) As Long

   NumFuncsSaved% = mnFunctionHistory - 1
   ErrorFound% = -1
   CurFunc% = gnCurFunc - 1
   If CurFunc% < 0 Then CurFunc% = NumFuncsSaved%
   For HistIndex% = 0 To NumFuncsSaved%
      If ULFunction = mavFuncsCalled(CurFunc%, 0) Then
         ErrorFound% = mavFuncsCalled(CurFunc%, 1)
         FuncNum% = ULFunction
         Func$ = GetFunctionName(FuncNum%)
         Func$ = Left(Func$, Len(Func$) - 2) & " ("
         FuncResult$ = ") = " & Format(ErrorFound%, "0")
         Argument% = 2
         FuncArgs = FuncArgs & mavFuncsCalled(CurFunc%, Argument%)
         If Not IsEmpty(FuncArgs) Then
            Do While Not (FuncArgs = "")
               ArgString$ = ArgString$ & FuncArgs & ", "
               Argument% = Argument% + 1
               FuncArgs = mavFuncsCalled(CurFunc%, Argument%)
            Loop
            ArgString$ = Func$ & Left(ArgString$, Len(ArgString$) - 2) & FuncResult$
         End If
         Exit For
      End If
      CurFunc% = CurFunc% - 1
      If CurFunc% < 0 Then CurFunc% = NumFuncsSaved%
   Next HistIndex%
   Arguments = ArgString$
   FindFunctionError = ErrorFound%

End Function
